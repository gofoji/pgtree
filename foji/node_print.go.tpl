// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.

package pgtree

import (
"errors"
"fmt"
"reflect"
"strings"
)

func (p *printer) printNode(node Node) (result string) {
p.level += 1
defer func() {
if p.debug {
pad := p.pad(p.level-1)
t := reflect.TypeOf(node)
name := t.Name()
if t.Kind() == reflect.Ptr {
name = t.Elem().Name()
}
p.debugOutput += fmt.Sprintln( pad + name + " = `" + strings.ReplaceAll(result, "\n", " \\n ") + "`")
}
p.level -= 1
}()
switch n := node.(type) {
case nil:
{{- range .Messages }}
	{{- if not (eq .MessageName "Node") }}
		case *{{ pascal .MessageName }}:
		if n == nil {
		return
		}
		return p.print{{ pascal .MessageName }}(n)
	{{- end }}
{{- end }}


case *Root:
return p.printNode(n.Node)
case Nodes:
return p.printNodes(n, " ")
default:
p.addError(errors.New("unhandled node type: " + reflect.TypeOf(node).String()))
}

return result
}
{{- range .Messages }}
	{{- if not (eq .MessageName "Node") }}

		func (p *printer) print{{ pascal .MessageName }}(node *{{ pascal .MessageName }}) string {
		p.addError(errors.New("{{ .MessageName }} not implemented"))
		return "NOT IMPLEMENTED"
		}
	{{- end }}
{{- end }}
