// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.

package pgtree

import (
	"errors"
	"fmt"
	"reflect"
	"strings"
	"unsafe"

	nodes "github.com/pganalyze/pg_query_go/v6"
)

// Thanks to zerolog for this utility
func isNilValue(i interface{}) bool {
	return (*[2]uintptr)(unsafe.Pointer(&i))[1] == 0
}

func (p *printer) printNode(node *nodes.Node) (result string) {
	if node == nil || isNilValue(node) {
		return
	}
	p.level += 1
	defer func() {
		if p.debug {
			pad := p.pad(p.level-1)
			t := reflect.TypeOf(node)
			name := t.Name()
			if t.Kind() == reflect.Ptr {
				name = t.Elem().Name()
			}
			debugLine := fmt.Sprintln(pad + name + " = `" + strings.ReplaceAll(result, "\n", " \\n ") + "`")
			p.debugOutput = append([]string{debugLine}, p.debugOutput...)
		}
		p.level -= 1
	}()

	switch n := node.Node.(type) {
	{{- range .Messages }}
        {{ $message :=  pascal .MessageName }}
        {{ if eq $message "String" -}}
            {{ $message = "String_" -}}
        {{ end -}}
        {{- if not (in $message "Node" "ParseResult" "ScanResult" "ScanToken") }}
			case *nodes.Node_{{ $message }}:
			return p.print{{ pascal .MessageName }}(n.{{$message}})
		{{- end }}
	{{- end }}

{{/*	case *nodes.Root:*/}}
{{/*		return p.printNode(n.Node)*/}}
{{/*	case nodes.Nodes:*/}}
{{/*		return p.printNodes(n, " ")*/}}
	default:
		p.addError(errors.New("unhandled node type: " + reflect.TypeOf(node).String()))
	}

	return result
}
{{- range .Messages }}
    {{ $message :=  pascal .MessageName }}
    {{ if eq $message "AStar" -}}
        {{ $message = "A_Star" -}}
    {{ else if eq $message "AConst" -}}
        {{ $message = "A_Const" -}}
    {{ else if eq $message "AArrayExpr" -}}
        {{ $message = "A_ArrayExpr" -}}
    {{ else if eq $message "AIndices" -}}
        {{ $message = "A_Indices" -}}
    {{ else if eq $message "AIndirection" -}}
        {{ $message = "A_Indirection" -}}
    {{ else if eq $message "AExpr" -}}
        {{ $message = "A_Expr" -}}
    {{ else if eq $message "SqlvalueFunction" -}}
        {{ $message = "SQLValueFunction" -}}
	{{ else if eq $message "CoerceViaIo" -}}
        {{ $message = "CoerceViaIO" -}}
	{{ else if eq $message "RtepermissionInfo" -}}
        {{ $message = "RTEPermissionInfo" -}}
	{{ else if eq $message "CtesearchClause" -}}
        {{ $message = "CTESearchClause" -}}
	{{ else if eq $message "CtecycleClause" -}}
        {{ $message = "CTECycleClause" -}}
	{{ else if eq $message "PlassignStmt" -}}
        {{ $message = "PLAssignStmt" -}}
	{{ else if eq $message "CreatePlangStmt" -}}
        {{ $message = "CreatePLangStmt" -}}
	{{ else if eq $message "AlterTsdictionaryStmt" -}}
        {{ $message = "AlterTSDictionaryStmt" -}}
	{{ else if eq $message "AlterTsconfigurationStmt" -}}
        {{ $message = "AlterTSConfigurationStmt" -}}
    {{ end -}}

    {{- if not (in $message "Node" "ParseResult" "ScanResult" "ScanToken") }}

func (p *printer) print{{ pascal .MessageName }}(node *nodes.{{ $message }}) string {
	p.addError(errors.New("{{ $message }} not implemented"))
	return "NOT IMPLEMENTED"
}
	{{- end }}
{{- end }}
