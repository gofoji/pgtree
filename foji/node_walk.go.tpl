// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.

package pgtree

type Visitor func(node Node, stack []Node, v Visitor) Visitor

func WalkList(list Nodes, stack []Node, v Visitor) {
	for _, n := range list {
		Walk(n, stack, v)
	}
}

func Walk(node Node, stack []Node, v Visitor) {
	if node == nil || isNilValue(node) {
		return
	}

	if v = v(node, stack, v); v == nil {
		return
	}

	stack = append(stack, node)
	switch n := node.(type) {
{{- range .Messages }}
	{{- if and (not (eq .MessageName "Node")) ($.HasMessage .) }}
		case *{{ pascal .MessageName }}:
		{{- range .Fields }}
			{{- if $.IsMessage .Type }}
				{{- if .IsRepeated }}
					WalkList(n.{{ pascal .FieldName }}, stack, v)
				{{- else }}
					Walk(n.{{ pascal .FieldName }}, stack, v)
				{{- end }}
			{{- end }}
		{{- end }}
	{{- end }}
{{- end }}
	case *Root:
		Walk(n.Node, stack, v)
	case Nodes:
		WalkList(n, stack, v)
	}
}

type MutateFunc func(node *Node, stack []*Node, visitor MutateFunc) MutateFunc

func mutateList(list Nodes, stack []*Node, v MutateFunc) {
	for i := range list {
		mutate(&list[i], stack, v)
	}
}

func mutate(node *Node, stack []*Node, v MutateFunc) {
	var nodeWrapper Node
	if node == nil || isNilValue(*node) {
		return
	}

	if v = v(node, stack, v); v == nil {
		return
	}

	stack = append(stack, node)

	switch n := (*node).(type) {
{{- range .Messages }}
	{{- if not (eq .MessageName "Node") }}
		case *{{ pascal .MessageName }}:
		{{- range .Fields }}
			{{- if $.IsMessage .Type }}
				{{- if .IsRepeated }}
					mutateList(n.{{ pascal .FieldName }}, stack, v)
				{{- else }}
					{{- if eq .Type "Node" }}
						mutate(&n.{{ pascal .FieldName }}, stack, v)
					{{- else }}
						nodeWrapper =  n.{{ pascal .FieldName }}
						mutate(&nodeWrapper, stack, v)
					{{- end }}
				{{- end }}
			{{- end }}
		{{- end }}
	{{- end }}
{{- end }}
	case *Root:
		mutate(&n.Node, stack, v)
	case Nodes:
		mutateList(n, stack, v)
	}
}
