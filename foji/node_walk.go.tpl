// Code generated by foji {{ version }}, template: {{ templateFile }}; DO NOT EDIT.

package pgtree

import (
	"github.com/gofoji/pgtree/nodes"
)

type Visitor func(node nodes.Node, stack []nodes.Node, v Visitor) Visitor

func WalkList(list nodes.Nodes, stack []nodes.Node, v Visitor) {
	for _, n := range list {
		Walk(n, stack, v)
	}
}

func Walk(node nodes.Node, stack []nodes.Node, v Visitor) {
	if node == nil || isNilValue(node) {
		return
	}

	if v = v(node, stack, v); v == nil {
		return
	}

	stack = append(stack, node)
	switch n := node.(type) {
{{- range .Messages }}
	{{- if and (not (eq .MessageName "Node")) ($.HasMessage .) }}
		case *nodes.{{ pascal .MessageName }}:
		{{- range .Fields }}
			{{- if $.IsMessage .Type }}
				{{- if .IsRepeated }}
					WalkList(n.{{ pascal .FieldName }}, stack, v)
				{{- else }}
					Walk(n.{{ pascal .FieldName }}, stack, v)
				{{- end }}
			{{- end }}
		{{- end }}
	{{- end }}
{{- end }}
	case *nodes.Root:
		Walk(n.Node, stack, v)
	case nodes.Nodes:
		WalkList(n, stack, v)
	}
}

type MutateFunc func(node *nodes.Node, stack []*nodes.Node, visitor MutateFunc) MutateFunc

func mutateList(list nodes.Nodes, stack []*nodes.Node, v MutateFunc) {
	for i := range list {
		mutate(&list[i], stack, v)
	}
}

func mutate(node *nodes.Node, stack []*nodes.Node, v MutateFunc) {
	var nodeWrapper nodes.Node
	if node == nil || isNilValue(*node) {
		return
	}

	if v = v(node, stack, v); v == nil {
		return
	}

	stack = append(stack, node)

	switch n := (*node).(type) {
{{- range .Messages }}
	{{- if not (eq .MessageName "Node") }}
		case *nodes.{{ pascal .MessageName }}:
		{{- range .Fields }}
			{{- if $.IsMessage .Type }}
				{{- if .IsRepeated }}
					mutateList(n.{{ pascal .FieldName }}, stack, v)
				{{- else }}
					{{- if eq .Type "Node" }}
						mutate(&n.{{ pascal .FieldName }}, stack, v)
					{{- else }}
						nodeWrapper =  n.{{ pascal .FieldName }}
						mutate(&nodeWrapper, stack, v)
					{{- end }}
				{{- end }}
			{{- end }}
		{{- end }}
	{{- end }}
{{- end }}
	case *nodes.Root:
		mutate(&n.Node, stack, v)
	case nodes.Nodes:
		mutateList(n, stack, v)
	}
}
