// Code generated by foji 0.3, template: foji/node_walk.go.tpl; DO NOT EDIT.

package pgtree

import (
	"fmt"
	"reflect"
	"strings"
)

type Visitor func(node Node, stack []Node, v Visitor) Visitor

func WalkList(list Nodes, stack []Node, v Visitor) {
	for _, n := range list {
		Walk(n, stack, v)
	}
}

func Walk(node Node, stack []Node, v Visitor) {
	if node == nil {
		return
	}
	if v = v(node, stack, v); v == nil {
		return
	}
	stack = append(stack, node)
	switch n := node.(type) {
	case nil:
		return
	case *Integer:
		if n == nil {
			return
		}
	case *Float:
		if n == nil {
			return
		}
	case *String:
		if n == nil {
			return
		}
	case *BitString:
		if n == nil {
			return
		}
	case *Null:
		if n == nil {
			return
		}
	case *List:
		if n == nil {
			return
		}
		WalkList(n.Items, stack, v)
	case *OidList:
		if n == nil {
			return
		}
		WalkList(n.Items, stack, v)
	case *IntList:
		if n == nil {
			return
		}
		WalkList(n.Items, stack, v)
	case *Alias:
		if n == nil {
			return
		}
		WalkList(n.Colnames, stack, v)
	case *RangeVar:
		if n == nil {
			return
		}
		Walk(n.Alias, stack, v)
	case *TableFunc:
		if n == nil {
			return
		}
		WalkList(n.NsUris, stack, v)
		WalkList(n.NsNames, stack, v)
		Walk(n.Docexpr, stack, v)
		Walk(n.Rowexpr, stack, v)
		WalkList(n.Colnames, stack, v)
		WalkList(n.Coltypes, stack, v)
		WalkList(n.Coltypmods, stack, v)
		WalkList(n.Colcollations, stack, v)
		WalkList(n.Colexprs, stack, v)
		WalkList(n.Coldefexprs, stack, v)
	case *Expr:
		if n == nil {
			return
		}
	case *Var:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
	case *Param:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
	case *Aggref:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		WalkList(n.Aggargtypes, stack, v)
		WalkList(n.Aggdirectargs, stack, v)
		WalkList(n.Args, stack, v)
		WalkList(n.Aggorder, stack, v)
		WalkList(n.Aggdistinct, stack, v)
		Walk(n.Aggfilter, stack, v)
	case *GroupingFunc:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		WalkList(n.Args, stack, v)
		WalkList(n.Refs, stack, v)
		WalkList(n.Cols, stack, v)
	case *WindowFunc:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		WalkList(n.Args, stack, v)
		Walk(n.Aggfilter, stack, v)
	case *SubscriptingRef:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		WalkList(n.Refupperindexpr, stack, v)
		WalkList(n.Reflowerindexpr, stack, v)
		Walk(n.Refexpr, stack, v)
		Walk(n.Refassgnexpr, stack, v)
	case *FuncExpr:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		WalkList(n.Args, stack, v)
	case *NamedArgExpr:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		Walk(n.Arg, stack, v)
	case *OpExpr:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		WalkList(n.Args, stack, v)
	case *DistinctExpr:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		WalkList(n.Args, stack, v)
	case *NullIfExpr:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		WalkList(n.Args, stack, v)
	case *ScalarArrayOpExpr:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		WalkList(n.Args, stack, v)
	case *BoolExpr:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		WalkList(n.Args, stack, v)
	case *SubLink:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		Walk(n.Testexpr, stack, v)
		WalkList(n.OperName, stack, v)
		Walk(n.Subselect, stack, v)
	case *SubPlan:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		Walk(n.Testexpr, stack, v)
		WalkList(n.ParamIds, stack, v)
		WalkList(n.SetParam, stack, v)
		WalkList(n.ParParam, stack, v)
		WalkList(n.Args, stack, v)
	case *AlternativeSubPlan:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		WalkList(n.Subplans, stack, v)
	case *FieldSelect:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		Walk(n.Arg, stack, v)
	case *FieldStore:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		Walk(n.Arg, stack, v)
		WalkList(n.Newvals, stack, v)
		WalkList(n.Fieldnums, stack, v)
	case *RelabelType:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		Walk(n.Arg, stack, v)
	case *CoerceViaIo:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		Walk(n.Arg, stack, v)
	case *ArrayCoerceExpr:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		Walk(n.Arg, stack, v)
		Walk(n.Elemexpr, stack, v)
	case *ConvertRowtypeExpr:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		Walk(n.Arg, stack, v)
	case *CollateExpr:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		Walk(n.Arg, stack, v)
	case *CaseExpr:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		Walk(n.Arg, stack, v)
		WalkList(n.Args, stack, v)
		Walk(n.Defresult, stack, v)
	case *CaseWhen:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		Walk(n.Expr, stack, v)
		Walk(n.Result, stack, v)
	case *CaseTestExpr:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
	case *ArrayExpr:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		WalkList(n.Elements, stack, v)
	case *RowExpr:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		WalkList(n.Args, stack, v)
		WalkList(n.Colnames, stack, v)
	case *RowCompareExpr:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		WalkList(n.Opnos, stack, v)
		WalkList(n.Opfamilies, stack, v)
		WalkList(n.Inputcollids, stack, v)
		WalkList(n.Largs, stack, v)
		WalkList(n.Rargs, stack, v)
	case *CoalesceExpr:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		WalkList(n.Args, stack, v)
	case *MinMaxExpr:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		WalkList(n.Args, stack, v)
	case *SqlvalueFunction:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
	case *XmlExpr:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		WalkList(n.NamedArgs, stack, v)
		WalkList(n.ArgNames, stack, v)
		WalkList(n.Args, stack, v)
	case *NullTest:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		Walk(n.Arg, stack, v)
	case *BooleanTest:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		Walk(n.Arg, stack, v)
	case *CoerceToDomain:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		Walk(n.Arg, stack, v)
	case *CoerceToDomainValue:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
	case *SetToDefault:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
	case *CurrentOfExpr:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
	case *NextValueExpr:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
	case *InferenceElem:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		Walk(n.Expr, stack, v)
	case *TargetEntry:
		if n == nil {
			return
		}
		Walk(n.Xpr, stack, v)
		Walk(n.Expr, stack, v)
	case *RangeTblRef:
		if n == nil {
			return
		}
	case *JoinExpr:
		if n == nil {
			return
		}
		Walk(n.Larg, stack, v)
		Walk(n.Rarg, stack, v)
		WalkList(n.UsingClause, stack, v)
		Walk(n.Quals, stack, v)
		Walk(n.Alias, stack, v)
	case *FromExpr:
		if n == nil {
			return
		}
		WalkList(n.Fromlist, stack, v)
		Walk(n.Quals, stack, v)
	case *OnConflictExpr:
		if n == nil {
			return
		}
		WalkList(n.ArbiterElems, stack, v)
		Walk(n.ArbiterWhere, stack, v)
		WalkList(n.OnConflictSet, stack, v)
		Walk(n.OnConflictWhere, stack, v)
		WalkList(n.ExclRelTlist, stack, v)
	case *IntoClause:
		if n == nil {
			return
		}
		Walk(n.Rel, stack, v)
		WalkList(n.ColNames, stack, v)
		WalkList(n.Options, stack, v)
		Walk(n.ViewQuery, stack, v)
	case *RawStmt:
		if n == nil {
			return
		}
		Walk(n.Stmt, stack, v)
	case *Query:
		if n == nil {
			return
		}
		Walk(n.UtilityStmt, stack, v)
		WalkList(n.CteList, stack, v)
		WalkList(n.Rtable, stack, v)
		Walk(n.Jointree, stack, v)
		WalkList(n.TargetList, stack, v)
		Walk(n.OnConflict, stack, v)
		WalkList(n.ReturningList, stack, v)
		WalkList(n.GroupClause, stack, v)
		WalkList(n.GroupingSets, stack, v)
		Walk(n.HavingQual, stack, v)
		WalkList(n.WindowClause, stack, v)
		WalkList(n.DistinctClause, stack, v)
		WalkList(n.SortClause, stack, v)
		Walk(n.LimitOffset, stack, v)
		Walk(n.LimitCount, stack, v)
		WalkList(n.RowMarks, stack, v)
		Walk(n.SetOperations, stack, v)
		WalkList(n.ConstraintDeps, stack, v)
		WalkList(n.WithCheckOptions, stack, v)
	case *InsertStmt:
		if n == nil {
			return
		}
		Walk(n.Relation, stack, v)
		WalkList(n.Cols, stack, v)
		Walk(n.SelectStmt, stack, v)
		Walk(n.OnConflictClause, stack, v)
		WalkList(n.ReturningList, stack, v)
		Walk(n.WithClause, stack, v)
	case *DeleteStmt:
		if n == nil {
			return
		}
		Walk(n.Relation, stack, v)
		WalkList(n.UsingClause, stack, v)
		Walk(n.WhereClause, stack, v)
		WalkList(n.ReturningList, stack, v)
		Walk(n.WithClause, stack, v)
	case *UpdateStmt:
		if n == nil {
			return
		}
		Walk(n.Relation, stack, v)
		WalkList(n.TargetList, stack, v)
		Walk(n.WhereClause, stack, v)
		WalkList(n.FromClause, stack, v)
		WalkList(n.ReturningList, stack, v)
		Walk(n.WithClause, stack, v)
	case *SelectStmt:
		if n == nil {
			return
		}
		WalkList(n.DistinctClause, stack, v)
		Walk(n.IntoClause, stack, v)
		WalkList(n.TargetList, stack, v)
		WalkList(n.FromClause, stack, v)
		Walk(n.WhereClause, stack, v)
		WalkList(n.GroupClause, stack, v)
		Walk(n.HavingClause, stack, v)
		WalkList(n.WindowClause, stack, v)
		WalkList(n.ValuesLists, stack, v)
		WalkList(n.SortClause, stack, v)
		Walk(n.LimitOffset, stack, v)
		Walk(n.LimitCount, stack, v)
		WalkList(n.LockingClause, stack, v)
		Walk(n.WithClause, stack, v)
		Walk(n.Larg, stack, v)
		Walk(n.Rarg, stack, v)
	case *AlterTableStmt:
		if n == nil {
			return
		}
		Walk(n.Relation, stack, v)
		WalkList(n.Cmds, stack, v)
	case *AlterTableCmd:
		if n == nil {
			return
		}
		Walk(n.Newowner, stack, v)
		Walk(n.Def, stack, v)
	case *AlterDomainStmt:
		if n == nil {
			return
		}
		WalkList(n.TypeName, stack, v)
		Walk(n.Def, stack, v)
	case *SetOperationStmt:
		if n == nil {
			return
		}
		Walk(n.Larg, stack, v)
		Walk(n.Rarg, stack, v)
		WalkList(n.ColTypes, stack, v)
		WalkList(n.ColTypmods, stack, v)
		WalkList(n.ColCollations, stack, v)
		WalkList(n.GroupClauses, stack, v)
	case *GrantStmt:
		if n == nil {
			return
		}
		WalkList(n.Objects, stack, v)
		WalkList(n.Privileges, stack, v)
		WalkList(n.Grantees, stack, v)
	case *GrantRoleStmt:
		if n == nil {
			return
		}
		WalkList(n.GrantedRoles, stack, v)
		WalkList(n.GranteeRoles, stack, v)
		Walk(n.Grantor, stack, v)
	case *AlterDefaultPrivilegesStmt:
		if n == nil {
			return
		}
		WalkList(n.Options, stack, v)
		Walk(n.Action, stack, v)
	case *ClosePortalStmt:
		if n == nil {
			return
		}
	case *ClusterStmt:
		if n == nil {
			return
		}
		Walk(n.Relation, stack, v)
	case *CopyStmt:
		if n == nil {
			return
		}
		Walk(n.Relation, stack, v)
		Walk(n.Query, stack, v)
		WalkList(n.Attlist, stack, v)
		WalkList(n.Options, stack, v)
		Walk(n.WhereClause, stack, v)
	case *CreateStmt:
		if n == nil {
			return
		}
		Walk(n.Relation, stack, v)
		WalkList(n.TableElts, stack, v)
		WalkList(n.InhRelations, stack, v)
		Walk(n.Partbound, stack, v)
		Walk(n.Partspec, stack, v)
		Walk(n.OfTypename, stack, v)
		WalkList(n.Constraints, stack, v)
		WalkList(n.Options, stack, v)
	case *DefineStmt:
		if n == nil {
			return
		}
		WalkList(n.Defnames, stack, v)
		WalkList(n.Args, stack, v)
		WalkList(n.Definition, stack, v)
	case *DropStmt:
		if n == nil {
			return
		}
		WalkList(n.Objects, stack, v)
	case *TruncateStmt:
		if n == nil {
			return
		}
		WalkList(n.Relations, stack, v)
	case *CommentStmt:
		if n == nil {
			return
		}
		Walk(n.Object, stack, v)
	case *FetchStmt:
		if n == nil {
			return
		}
	case *IndexStmt:
		if n == nil {
			return
		}
		Walk(n.Relation, stack, v)
		WalkList(n.IndexParams, stack, v)
		WalkList(n.IndexIncludingParams, stack, v)
		WalkList(n.Options, stack, v)
		Walk(n.WhereClause, stack, v)
		WalkList(n.ExcludeOpNames, stack, v)
	case *CreateFunctionStmt:
		if n == nil {
			return
		}
		WalkList(n.Funcname, stack, v)
		WalkList(n.Parameters, stack, v)
		Walk(n.ReturnType, stack, v)
		WalkList(n.Options, stack, v)
	case *AlterFunctionStmt:
		if n == nil {
			return
		}
		Walk(n.Func, stack, v)
		WalkList(n.Actions, stack, v)
	case *DoStmt:
		if n == nil {
			return
		}
		WalkList(n.Args, stack, v)
	case *RenameStmt:
		if n == nil {
			return
		}
		Walk(n.Relation, stack, v)
		Walk(n.Object, stack, v)
	case *RuleStmt:
		if n == nil {
			return
		}
		Walk(n.Relation, stack, v)
		Walk(n.WhereClause, stack, v)
		WalkList(n.Actions, stack, v)
	case *NotifyStmt:
		if n == nil {
			return
		}
	case *ListenStmt:
		if n == nil {
			return
		}
	case *UnlistenStmt:
		if n == nil {
			return
		}
	case *TransactionStmt:
		if n == nil {
			return
		}
		WalkList(n.Options, stack, v)
	case *ViewStmt:
		if n == nil {
			return
		}
		Walk(n.View, stack, v)
		WalkList(n.Aliases, stack, v)
		Walk(n.Query, stack, v)
		WalkList(n.Options, stack, v)
	case *LoadStmt:
		if n == nil {
			return
		}
	case *CreateDomainStmt:
		if n == nil {
			return
		}
		WalkList(n.Domainname, stack, v)
		Walk(n.TypeName, stack, v)
		Walk(n.CollClause, stack, v)
		WalkList(n.Constraints, stack, v)
	case *CreatedbStmt:
		if n == nil {
			return
		}
		WalkList(n.Options, stack, v)
	case *DropdbStmt:
		if n == nil {
			return
		}
	case *VacuumStmt:
		if n == nil {
			return
		}
		WalkList(n.Options, stack, v)
		WalkList(n.Rels, stack, v)
	case *ExplainStmt:
		if n == nil {
			return
		}
		Walk(n.Query, stack, v)
		WalkList(n.Options, stack, v)
	case *CreateTableAsStmt:
		if n == nil {
			return
		}
		Walk(n.Query, stack, v)
		Walk(n.Into, stack, v)
	case *CreateSeqStmt:
		if n == nil {
			return
		}
		Walk(n.Sequence, stack, v)
		WalkList(n.Options, stack, v)
	case *AlterSeqStmt:
		if n == nil {
			return
		}
		Walk(n.Sequence, stack, v)
		WalkList(n.Options, stack, v)
	case *VariableSetStmt:
		if n == nil {
			return
		}
		WalkList(n.Args, stack, v)
	case *VariableShowStmt:
		if n == nil {
			return
		}
	case *DiscardStmt:
		if n == nil {
			return
		}
	case *CreateTrigStmt:
		if n == nil {
			return
		}
		Walk(n.Relation, stack, v)
		WalkList(n.Funcname, stack, v)
		WalkList(n.Args, stack, v)
		WalkList(n.Columns, stack, v)
		Walk(n.WhenClause, stack, v)
		WalkList(n.TransitionRels, stack, v)
		Walk(n.Constrrel, stack, v)
	case *CreatePlangStmt:
		if n == nil {
			return
		}
		WalkList(n.Plhandler, stack, v)
		WalkList(n.Plinline, stack, v)
		WalkList(n.Plvalidator, stack, v)
	case *CreateRoleStmt:
		if n == nil {
			return
		}
		WalkList(n.Options, stack, v)
	case *AlterRoleStmt:
		if n == nil {
			return
		}
		Walk(n.Role, stack, v)
		WalkList(n.Options, stack, v)
	case *DropRoleStmt:
		if n == nil {
			return
		}
		WalkList(n.Roles, stack, v)
	case *LockStmt:
		if n == nil {
			return
		}
		WalkList(n.Relations, stack, v)
	case *ConstraintsSetStmt:
		if n == nil {
			return
		}
		WalkList(n.Constraints, stack, v)
	case *ReindexStmt:
		if n == nil {
			return
		}
		Walk(n.Relation, stack, v)
	case *CheckPointStmt:
		if n == nil {
			return
		}
	case *CreateSchemaStmt:
		if n == nil {
			return
		}
		Walk(n.Authrole, stack, v)
		WalkList(n.SchemaElts, stack, v)
	case *AlterDatabaseStmt:
		if n == nil {
			return
		}
		WalkList(n.Options, stack, v)
	case *AlterDatabaseSetStmt:
		if n == nil {
			return
		}
		Walk(n.Setstmt, stack, v)
	case *AlterRoleSetStmt:
		if n == nil {
			return
		}
		Walk(n.Role, stack, v)
		Walk(n.Setstmt, stack, v)
	case *CreateConversionStmt:
		if n == nil {
			return
		}
		WalkList(n.ConversionName, stack, v)
		WalkList(n.FuncName, stack, v)
	case *CreateCastStmt:
		if n == nil {
			return
		}
		Walk(n.Sourcetype, stack, v)
		Walk(n.Targettype, stack, v)
		Walk(n.Func, stack, v)
	case *CreateOpClassStmt:
		if n == nil {
			return
		}
		WalkList(n.Opclassname, stack, v)
		WalkList(n.Opfamilyname, stack, v)
		Walk(n.Datatype, stack, v)
		WalkList(n.Items, stack, v)
	case *CreateOpFamilyStmt:
		if n == nil {
			return
		}
		WalkList(n.Opfamilyname, stack, v)
	case *AlterOpFamilyStmt:
		if n == nil {
			return
		}
		WalkList(n.Opfamilyname, stack, v)
		WalkList(n.Items, stack, v)
	case *PrepareStmt:
		if n == nil {
			return
		}
		WalkList(n.Argtypes, stack, v)
		Walk(n.Query, stack, v)
	case *ExecuteStmt:
		if n == nil {
			return
		}
		WalkList(n.Params, stack, v)
	case *DeallocateStmt:
		if n == nil {
			return
		}
	case *DeclareCursorStmt:
		if n == nil {
			return
		}
		Walk(n.Query, stack, v)
	case *CreateTableSpaceStmt:
		if n == nil {
			return
		}
		Walk(n.Owner, stack, v)
		WalkList(n.Options, stack, v)
	case *DropTableSpaceStmt:
		if n == nil {
			return
		}
	case *AlterObjectDependsStmt:
		if n == nil {
			return
		}
		Walk(n.Relation, stack, v)
		Walk(n.Object, stack, v)
		Walk(n.Extname, stack, v)
	case *AlterObjectSchemaStmt:
		if n == nil {
			return
		}
		Walk(n.Relation, stack, v)
		Walk(n.Object, stack, v)
	case *AlterOwnerStmt:
		if n == nil {
			return
		}
		Walk(n.Relation, stack, v)
		Walk(n.Object, stack, v)
		Walk(n.Newowner, stack, v)
	case *AlterOperatorStmt:
		if n == nil {
			return
		}
		Walk(n.Opername, stack, v)
		WalkList(n.Options, stack, v)
	case *DropOwnedStmt:
		if n == nil {
			return
		}
		WalkList(n.Roles, stack, v)
	case *ReassignOwnedStmt:
		if n == nil {
			return
		}
		WalkList(n.Roles, stack, v)
		Walk(n.Newrole, stack, v)
	case *CompositeTypeStmt:
		if n == nil {
			return
		}
		Walk(n.Typevar, stack, v)
		WalkList(n.Coldeflist, stack, v)
	case *CreateEnumStmt:
		if n == nil {
			return
		}
		WalkList(n.TypeName, stack, v)
		WalkList(n.Vals, stack, v)
	case *CreateRangeStmt:
		if n == nil {
			return
		}
		WalkList(n.TypeName, stack, v)
		WalkList(n.Params, stack, v)
	case *AlterEnumStmt:
		if n == nil {
			return
		}
		WalkList(n.TypeName, stack, v)
	case *AlterTsdictionaryStmt:
		if n == nil {
			return
		}
		WalkList(n.Dictname, stack, v)
		WalkList(n.Options, stack, v)
	case *AlterTsconfigurationStmt:
		if n == nil {
			return
		}
		WalkList(n.Cfgname, stack, v)
		WalkList(n.Tokentype, stack, v)
		WalkList(n.Dicts, stack, v)
	case *CreateFdwStmt:
		if n == nil {
			return
		}
		WalkList(n.FuncOptions, stack, v)
		WalkList(n.Options, stack, v)
	case *AlterFdwStmt:
		if n == nil {
			return
		}
		WalkList(n.FuncOptions, stack, v)
		WalkList(n.Options, stack, v)
	case *CreateForeignServerStmt:
		if n == nil {
			return
		}
		WalkList(n.Options, stack, v)
	case *AlterForeignServerStmt:
		if n == nil {
			return
		}
		WalkList(n.Options, stack, v)
	case *CreateUserMappingStmt:
		if n == nil {
			return
		}
		Walk(n.User, stack, v)
		WalkList(n.Options, stack, v)
	case *AlterUserMappingStmt:
		if n == nil {
			return
		}
		Walk(n.User, stack, v)
		WalkList(n.Options, stack, v)
	case *DropUserMappingStmt:
		if n == nil {
			return
		}
		Walk(n.User, stack, v)
	case *AlterTableSpaceOptionsStmt:
		if n == nil {
			return
		}
		WalkList(n.Options, stack, v)
	case *AlterTableMoveAllStmt:
		if n == nil {
			return
		}
		WalkList(n.Roles, stack, v)
	case *SecLabelStmt:
		if n == nil {
			return
		}
		Walk(n.Object, stack, v)
	case *CreateForeignTableStmt:
		if n == nil {
			return
		}
		Walk(n.Base, stack, v)
		WalkList(n.Options, stack, v)
	case *ImportForeignSchemaStmt:
		if n == nil {
			return
		}
		WalkList(n.TableList, stack, v)
		WalkList(n.Options, stack, v)
	case *CreateExtensionStmt:
		if n == nil {
			return
		}
		WalkList(n.Options, stack, v)
	case *AlterExtensionStmt:
		if n == nil {
			return
		}
		WalkList(n.Options, stack, v)
	case *AlterExtensionContentsStmt:
		if n == nil {
			return
		}
		Walk(n.Object, stack, v)
	case *CreateEventTrigStmt:
		if n == nil {
			return
		}
		WalkList(n.Whenclause, stack, v)
		WalkList(n.Funcname, stack, v)
	case *AlterEventTrigStmt:
		if n == nil {
			return
		}
	case *RefreshMatViewStmt:
		if n == nil {
			return
		}
		Walk(n.Relation, stack, v)
	case *ReplicaIdentityStmt:
		if n == nil {
			return
		}
	case *AlterSystemStmt:
		if n == nil {
			return
		}
		Walk(n.Setstmt, stack, v)
	case *CreatePolicyStmt:
		if n == nil {
			return
		}
		Walk(n.Table, stack, v)
		WalkList(n.Roles, stack, v)
		Walk(n.Qual, stack, v)
		Walk(n.WithCheck, stack, v)
	case *AlterPolicyStmt:
		if n == nil {
			return
		}
		Walk(n.Table, stack, v)
		WalkList(n.Roles, stack, v)
		Walk(n.Qual, stack, v)
		Walk(n.WithCheck, stack, v)
	case *CreateTransformStmt:
		if n == nil {
			return
		}
		Walk(n.TypeName, stack, v)
		Walk(n.Fromsql, stack, v)
		Walk(n.Tosql, stack, v)
	case *CreateAmStmt:
		if n == nil {
			return
		}
		WalkList(n.HandlerName, stack, v)
	case *CreatePublicationStmt:
		if n == nil {
			return
		}
		WalkList(n.Options, stack, v)
		WalkList(n.Tables, stack, v)
	case *AlterPublicationStmt:
		if n == nil {
			return
		}
		WalkList(n.Options, stack, v)
		WalkList(n.Tables, stack, v)
	case *CreateSubscriptionStmt:
		if n == nil {
			return
		}
		WalkList(n.Publication, stack, v)
		WalkList(n.Options, stack, v)
	case *AlterSubscriptionStmt:
		if n == nil {
			return
		}
		WalkList(n.Publication, stack, v)
		WalkList(n.Options, stack, v)
	case *DropSubscriptionStmt:
		if n == nil {
			return
		}
	case *CreateStatsStmt:
		if n == nil {
			return
		}
		WalkList(n.Defnames, stack, v)
		WalkList(n.StatTypes, stack, v)
		WalkList(n.Exprs, stack, v)
		WalkList(n.Relations, stack, v)
	case *AlterCollationStmt:
		if n == nil {
			return
		}
		WalkList(n.Collname, stack, v)
	case *CallStmt:
		if n == nil {
			return
		}
		Walk(n.Funccall, stack, v)
		Walk(n.Funcexpr, stack, v)
	case *AExpr:
		if n == nil {
			return
		}
		WalkList(n.Name, stack, v)
		Walk(n.Lexpr, stack, v)
		Walk(n.Rexpr, stack, v)
	case *ColumnRef:
		if n == nil {
			return
		}
		WalkList(n.Fields, stack, v)
	case *ParamRef:
		if n == nil {
			return
		}
	case *AConst:
		if n == nil {
			return
		}
		Walk(n.Val, stack, v)
	case *FuncCall:
		if n == nil {
			return
		}
		WalkList(n.Funcname, stack, v)
		WalkList(n.Args, stack, v)
		WalkList(n.AggOrder, stack, v)
		Walk(n.AggFilter, stack, v)
		Walk(n.Over, stack, v)
	case *AStar:
		if n == nil {
			return
		}
	case *AIndices:
		if n == nil {
			return
		}
		Walk(n.Lidx, stack, v)
		Walk(n.Uidx, stack, v)
	case *AIndirection:
		if n == nil {
			return
		}
		Walk(n.Arg, stack, v)
		WalkList(n.Indirection, stack, v)
	case *AArrayExpr:
		if n == nil {
			return
		}
		WalkList(n.Elements, stack, v)
	case *ResTarget:
		if n == nil {
			return
		}
		WalkList(n.Indirection, stack, v)
		Walk(n.Val, stack, v)
	case *MultiAssignRef:
		if n == nil {
			return
		}
		Walk(n.Source, stack, v)
	case *TypeCast:
		if n == nil {
			return
		}
		Walk(n.Arg, stack, v)
		Walk(n.TypeName, stack, v)
	case *CollateClause:
		if n == nil {
			return
		}
		Walk(n.Arg, stack, v)
		WalkList(n.Collname, stack, v)
	case *SortBy:
		if n == nil {
			return
		}
		Walk(n.Node, stack, v)
		WalkList(n.UseOp, stack, v)
	case *WindowDef:
		if n == nil {
			return
		}
		WalkList(n.PartitionClause, stack, v)
		WalkList(n.OrderClause, stack, v)
		Walk(n.StartOffset, stack, v)
		Walk(n.EndOffset, stack, v)
	case *RangeSubselect:
		if n == nil {
			return
		}
		Walk(n.Subquery, stack, v)
		Walk(n.Alias, stack, v)
	case *RangeFunction:
		if n == nil {
			return
		}
		WalkList(n.Functions, stack, v)
		Walk(n.Alias, stack, v)
		WalkList(n.Coldeflist, stack, v)
	case *RangeTableSample:
		if n == nil {
			return
		}
		Walk(n.Relation, stack, v)
		WalkList(n.Method, stack, v)
		WalkList(n.Args, stack, v)
		Walk(n.Repeatable, stack, v)
	case *RangeTableFunc:
		if n == nil {
			return
		}
		Walk(n.Docexpr, stack, v)
		Walk(n.Rowexpr, stack, v)
		WalkList(n.Namespaces, stack, v)
		WalkList(n.Columns, stack, v)
		Walk(n.Alias, stack, v)
	case *RangeTableFuncCol:
		if n == nil {
			return
		}
		Walk(n.TypeName, stack, v)
		Walk(n.Colexpr, stack, v)
		Walk(n.Coldefexpr, stack, v)
	case *TypeName:
		if n == nil {
			return
		}
		WalkList(n.Names, stack, v)
		WalkList(n.Typmods, stack, v)
		WalkList(n.ArrayBounds, stack, v)
	case *ColumnDef:
		if n == nil {
			return
		}
		Walk(n.TypeName, stack, v)
		Walk(n.RawDefault, stack, v)
		Walk(n.CookedDefault, stack, v)
		Walk(n.IdentitySequence, stack, v)
		Walk(n.CollClause, stack, v)
		WalkList(n.Constraints, stack, v)
		WalkList(n.Fdwoptions, stack, v)
	case *IndexElem:
		if n == nil {
			return
		}
		Walk(n.Expr, stack, v)
		WalkList(n.Collation, stack, v)
		WalkList(n.Opclass, stack, v)
	case *Constraint:
		if n == nil {
			return
		}
		Walk(n.RawExpr, stack, v)
		WalkList(n.Keys, stack, v)
		WalkList(n.Including, stack, v)
		WalkList(n.Exclusions, stack, v)
		WalkList(n.Options, stack, v)
		Walk(n.WhereClause, stack, v)
		Walk(n.Pktable, stack, v)
		WalkList(n.FkAttrs, stack, v)
		WalkList(n.PkAttrs, stack, v)
		WalkList(n.OldConpfeqop, stack, v)
	case *DefElem:
		if n == nil {
			return
		}
		Walk(n.Arg, stack, v)
	case *RangeTblEntry:
		if n == nil {
			return
		}
		Walk(n.Tablesample, stack, v)
		Walk(n.Subquery, stack, v)
		WalkList(n.Joinaliasvars, stack, v)
		WalkList(n.Functions, stack, v)
		Walk(n.Tablefunc, stack, v)
		WalkList(n.ValuesLists, stack, v)
		WalkList(n.Coltypes, stack, v)
		WalkList(n.Coltypmods, stack, v)
		WalkList(n.Colcollations, stack, v)
		Walk(n.Alias, stack, v)
		Walk(n.Eref, stack, v)
		WalkList(n.SecurityQuals, stack, v)
	case *RangeTblFunction:
		if n == nil {
			return
		}
		Walk(n.Funcexpr, stack, v)
		WalkList(n.Funccolnames, stack, v)
		WalkList(n.Funccoltypes, stack, v)
		WalkList(n.Funccoltypmods, stack, v)
		WalkList(n.Funccolcollations, stack, v)
	case *TableSampleClause:
		if n == nil {
			return
		}
		WalkList(n.Args, stack, v)
		Walk(n.Repeatable, stack, v)
	case *WithCheckOption:
		if n == nil {
			return
		}
		Walk(n.Qual, stack, v)
	case *SortGroupClause:
		if n == nil {
			return
		}
	case *GroupingSet:
		if n == nil {
			return
		}
		WalkList(n.Content, stack, v)
	case *WindowClause:
		if n == nil {
			return
		}
		WalkList(n.PartitionClause, stack, v)
		WalkList(n.OrderClause, stack, v)
		Walk(n.StartOffset, stack, v)
		Walk(n.EndOffset, stack, v)
	case *ObjectWithArgs:
		if n == nil {
			return
		}
		WalkList(n.Objname, stack, v)
		WalkList(n.Objargs, stack, v)
	case *AccessPriv:
		if n == nil {
			return
		}
		WalkList(n.Cols, stack, v)
	case *CreateOpClassItem:
		if n == nil {
			return
		}
		Walk(n.Name, stack, v)
		WalkList(n.OrderFamily, stack, v)
		WalkList(n.ClassArgs, stack, v)
		Walk(n.Storedtype, stack, v)
	case *TableLikeClause:
		if n == nil {
			return
		}
		Walk(n.Relation, stack, v)
	case *FunctionParameter:
		if n == nil {
			return
		}
		Walk(n.ArgType, stack, v)
		Walk(n.Defexpr, stack, v)
	case *LockingClause:
		if n == nil {
			return
		}
		WalkList(n.LockedRels, stack, v)
	case *RowMarkClause:
		if n == nil {
			return
		}
	case *XmlSerialize:
		if n == nil {
			return
		}
		Walk(n.Expr, stack, v)
		Walk(n.TypeName, stack, v)
	case *WithClause:
		if n == nil {
			return
		}
		WalkList(n.Ctes, stack, v)
	case *InferClause:
		if n == nil {
			return
		}
		WalkList(n.IndexElems, stack, v)
		Walk(n.WhereClause, stack, v)
	case *OnConflictClause:
		if n == nil {
			return
		}
		Walk(n.Infer, stack, v)
		WalkList(n.TargetList, stack, v)
		Walk(n.WhereClause, stack, v)
	case *CommonTableExpr:
		if n == nil {
			return
		}
		WalkList(n.Aliascolnames, stack, v)
		Walk(n.Ctequery, stack, v)
		WalkList(n.Ctecolnames, stack, v)
		WalkList(n.Ctecoltypes, stack, v)
		WalkList(n.Ctecoltypmods, stack, v)
		WalkList(n.Ctecolcollations, stack, v)
	case *RoleSpec:
		if n == nil {
			return
		}
	case *TriggerTransition:
		if n == nil {
			return
		}
	case *PartitionElem:
		if n == nil {
			return
		}
		Walk(n.Expr, stack, v)
		WalkList(n.Collation, stack, v)
		WalkList(n.Opclass, stack, v)
	case *PartitionSpec:
		if n == nil {
			return
		}
		WalkList(n.PartParams, stack, v)
	case *PartitionBoundSpec:
		if n == nil {
			return
		}
		WalkList(n.Listdatums, stack, v)
		WalkList(n.Lowerdatums, stack, v)
		WalkList(n.Upperdatums, stack, v)
	case *PartitionRangeDatum:
		if n == nil {
			return
		}
		Walk(n.Value, stack, v)
	case *PartitionCmd:
		if n == nil {
			return
		}
		Walk(n.Name, stack, v)
		Walk(n.Bound, stack, v)
	case *VacuumRelation:
		if n == nil {
			return
		}
		Walk(n.Relation, stack, v)
		WalkList(n.VaCols, stack, v)
	case *InlineCodeBlock:
		if n == nil {
			return
		}
	case *CallContext:
		if n == nil {
			return
		}
	case *Root:
		Walk(n.Node, stack, v)
	case Nodes:
		for _, n2 := range n {
			Walk(n2, stack, v)
		}
	default:
		fmt.Printf("!%s%s\n", strings.Repeat("  ", len(stack)), reflect.TypeOf(node).Name())
	}
}

type MutateFunc func(node *Node, stack []*Node, visitor MutateFunc) MutateFunc

func mutateList(list Nodes, stack []*Node, v MutateFunc) {
	for i := range list {
		mutate(&list[i], stack, v)
	}
}

func mutate(node *Node, stack []*Node, v MutateFunc) {
	var nodeWrapper Node
	if node == nil {
		return
	}
	if v = v(node, stack, v); v == nil {
		return
	}
	stack = append(stack, node)
	switch n := (*node).(type) {
	case nil:
		return
	case *Integer:
		if n == nil {
			return
		}
	case *Float:
		if n == nil {
			return
		}
	case *String:
		if n == nil {
			return
		}
	case *BitString:
		if n == nil {
			return
		}
	case *Null:
		if n == nil {
			return
		}
	case *List:
		if n == nil {
			return
		}
		mutateList(n.Items, stack, v)
	case *OidList:
		if n == nil {
			return
		}
		mutateList(n.Items, stack, v)
	case *IntList:
		if n == nil {
			return
		}
		mutateList(n.Items, stack, v)
	case *Alias:
		if n == nil {
			return
		}
		mutateList(n.Colnames, stack, v)
	case *RangeVar:
		if n == nil {
			return
		}
		nodeWrapper = n.Alias
		mutate(&nodeWrapper, stack, v)
	case *TableFunc:
		if n == nil {
			return
		}
		mutateList(n.NsUris, stack, v)
		mutateList(n.NsNames, stack, v)
		mutate(&n.Docexpr, stack, v)
		mutate(&n.Rowexpr, stack, v)
		mutateList(n.Colnames, stack, v)
		mutateList(n.Coltypes, stack, v)
		mutateList(n.Coltypmods, stack, v)
		mutateList(n.Colcollations, stack, v)
		mutateList(n.Colexprs, stack, v)
		mutateList(n.Coldefexprs, stack, v)
	case *Expr:
		if n == nil {
			return
		}
	case *Var:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
	case *Param:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
	case *Aggref:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutateList(n.Aggargtypes, stack, v)
		mutateList(n.Aggdirectargs, stack, v)
		mutateList(n.Args, stack, v)
		mutateList(n.Aggorder, stack, v)
		mutateList(n.Aggdistinct, stack, v)
		mutate(&n.Aggfilter, stack, v)
	case *GroupingFunc:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutateList(n.Args, stack, v)
		mutateList(n.Refs, stack, v)
		mutateList(n.Cols, stack, v)
	case *WindowFunc:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutateList(n.Args, stack, v)
		mutate(&n.Aggfilter, stack, v)
	case *SubscriptingRef:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutateList(n.Refupperindexpr, stack, v)
		mutateList(n.Reflowerindexpr, stack, v)
		mutate(&n.Refexpr, stack, v)
		mutate(&n.Refassgnexpr, stack, v)
	case *FuncExpr:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutateList(n.Args, stack, v)
	case *NamedArgExpr:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutate(&n.Arg, stack, v)
	case *OpExpr:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutateList(n.Args, stack, v)
	case *DistinctExpr:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutateList(n.Args, stack, v)
	case *NullIfExpr:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutateList(n.Args, stack, v)
	case *ScalarArrayOpExpr:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutateList(n.Args, stack, v)
	case *BoolExpr:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutateList(n.Args, stack, v)
	case *SubLink:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutate(&n.Testexpr, stack, v)
		mutateList(n.OperName, stack, v)
		mutate(&n.Subselect, stack, v)
	case *SubPlan:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutate(&n.Testexpr, stack, v)
		mutateList(n.ParamIds, stack, v)
		mutateList(n.SetParam, stack, v)
		mutateList(n.ParParam, stack, v)
		mutateList(n.Args, stack, v)
	case *AlternativeSubPlan:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutateList(n.Subplans, stack, v)
	case *FieldSelect:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutate(&n.Arg, stack, v)
	case *FieldStore:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutate(&n.Arg, stack, v)
		mutateList(n.Newvals, stack, v)
		mutateList(n.Fieldnums, stack, v)
	case *RelabelType:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutate(&n.Arg, stack, v)
	case *CoerceViaIo:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutate(&n.Arg, stack, v)
	case *ArrayCoerceExpr:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutate(&n.Arg, stack, v)
		mutate(&n.Elemexpr, stack, v)
	case *ConvertRowtypeExpr:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutate(&n.Arg, stack, v)
	case *CollateExpr:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutate(&n.Arg, stack, v)
	case *CaseExpr:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutate(&n.Arg, stack, v)
		mutateList(n.Args, stack, v)
		mutate(&n.Defresult, stack, v)
	case *CaseWhen:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutate(&n.Expr, stack, v)
		mutate(&n.Result, stack, v)
	case *CaseTestExpr:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
	case *ArrayExpr:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutateList(n.Elements, stack, v)
	case *RowExpr:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutateList(n.Args, stack, v)
		mutateList(n.Colnames, stack, v)
	case *RowCompareExpr:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutateList(n.Opnos, stack, v)
		mutateList(n.Opfamilies, stack, v)
		mutateList(n.Inputcollids, stack, v)
		mutateList(n.Largs, stack, v)
		mutateList(n.Rargs, stack, v)
	case *CoalesceExpr:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutateList(n.Args, stack, v)
	case *MinMaxExpr:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutateList(n.Args, stack, v)
	case *SqlvalueFunction:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
	case *XmlExpr:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutateList(n.NamedArgs, stack, v)
		mutateList(n.ArgNames, stack, v)
		mutateList(n.Args, stack, v)
	case *NullTest:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutate(&n.Arg, stack, v)
	case *BooleanTest:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutate(&n.Arg, stack, v)
	case *CoerceToDomain:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutate(&n.Arg, stack, v)
	case *CoerceToDomainValue:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
	case *SetToDefault:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
	case *CurrentOfExpr:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
	case *NextValueExpr:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
	case *InferenceElem:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutate(&n.Expr, stack, v)
	case *TargetEntry:
		if n == nil {
			return
		}
		mutate(&n.Xpr, stack, v)
		mutate(&n.Expr, stack, v)
	case *RangeTblRef:
		if n == nil {
			return
		}
	case *JoinExpr:
		if n == nil {
			return
		}
		mutate(&n.Larg, stack, v)
		mutate(&n.Rarg, stack, v)
		mutateList(n.UsingClause, stack, v)
		mutate(&n.Quals, stack, v)
		nodeWrapper = n.Alias
		mutate(&nodeWrapper, stack, v)
	case *FromExpr:
		if n == nil {
			return
		}
		mutateList(n.Fromlist, stack, v)
		mutate(&n.Quals, stack, v)
	case *OnConflictExpr:
		if n == nil {
			return
		}
		mutateList(n.ArbiterElems, stack, v)
		mutate(&n.ArbiterWhere, stack, v)
		mutateList(n.OnConflictSet, stack, v)
		mutate(&n.OnConflictWhere, stack, v)
		mutateList(n.ExclRelTlist, stack, v)
	case *IntoClause:
		if n == nil {
			return
		}
		nodeWrapper = n.Rel
		mutate(&nodeWrapper, stack, v)
		mutateList(n.ColNames, stack, v)
		mutateList(n.Options, stack, v)
		mutate(&n.ViewQuery, stack, v)
	case *RawStmt:
		if n == nil {
			return
		}
		mutate(&n.Stmt, stack, v)
	case *Query:
		if n == nil {
			return
		}
		mutate(&n.UtilityStmt, stack, v)
		mutateList(n.CteList, stack, v)
		mutateList(n.Rtable, stack, v)
		nodeWrapper = n.Jointree
		mutate(&nodeWrapper, stack, v)
		mutateList(n.TargetList, stack, v)
		nodeWrapper = n.OnConflict
		mutate(&nodeWrapper, stack, v)
		mutateList(n.ReturningList, stack, v)
		mutateList(n.GroupClause, stack, v)
		mutateList(n.GroupingSets, stack, v)
		mutate(&n.HavingQual, stack, v)
		mutateList(n.WindowClause, stack, v)
		mutateList(n.DistinctClause, stack, v)
		mutateList(n.SortClause, stack, v)
		mutate(&n.LimitOffset, stack, v)
		mutate(&n.LimitCount, stack, v)
		mutateList(n.RowMarks, stack, v)
		mutate(&n.SetOperations, stack, v)
		mutateList(n.ConstraintDeps, stack, v)
		mutateList(n.WithCheckOptions, stack, v)
	case *InsertStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Relation
		mutate(&nodeWrapper, stack, v)
		mutateList(n.Cols, stack, v)
		mutate(&n.SelectStmt, stack, v)
		nodeWrapper = n.OnConflictClause
		mutate(&nodeWrapper, stack, v)
		mutateList(n.ReturningList, stack, v)
		nodeWrapper = n.WithClause
		mutate(&nodeWrapper, stack, v)
	case *DeleteStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Relation
		mutate(&nodeWrapper, stack, v)
		mutateList(n.UsingClause, stack, v)
		mutate(&n.WhereClause, stack, v)
		mutateList(n.ReturningList, stack, v)
		nodeWrapper = n.WithClause
		mutate(&nodeWrapper, stack, v)
	case *UpdateStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Relation
		mutate(&nodeWrapper, stack, v)
		mutateList(n.TargetList, stack, v)
		mutate(&n.WhereClause, stack, v)
		mutateList(n.FromClause, stack, v)
		mutateList(n.ReturningList, stack, v)
		nodeWrapper = n.WithClause
		mutate(&nodeWrapper, stack, v)
	case *SelectStmt:
		if n == nil {
			return
		}
		mutateList(n.DistinctClause, stack, v)
		nodeWrapper = n.IntoClause
		mutate(&nodeWrapper, stack, v)
		mutateList(n.TargetList, stack, v)
		mutateList(n.FromClause, stack, v)
		mutate(&n.WhereClause, stack, v)
		mutateList(n.GroupClause, stack, v)
		mutate(&n.HavingClause, stack, v)
		mutateList(n.WindowClause, stack, v)
		mutateList(n.ValuesLists, stack, v)
		mutateList(n.SortClause, stack, v)
		mutate(&n.LimitOffset, stack, v)
		mutate(&n.LimitCount, stack, v)
		mutateList(n.LockingClause, stack, v)
		nodeWrapper = n.WithClause
		mutate(&nodeWrapper, stack, v)
		nodeWrapper = n.Larg
		mutate(&nodeWrapper, stack, v)
		nodeWrapper = n.Rarg
		mutate(&nodeWrapper, stack, v)
	case *AlterTableStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Relation
		mutate(&nodeWrapper, stack, v)
		mutateList(n.Cmds, stack, v)
	case *AlterTableCmd:
		if n == nil {
			return
		}
		nodeWrapper = n.Newowner
		mutate(&nodeWrapper, stack, v)
		mutate(&n.Def, stack, v)
	case *AlterDomainStmt:
		if n == nil {
			return
		}
		mutateList(n.TypeName, stack, v)
		mutate(&n.Def, stack, v)
	case *SetOperationStmt:
		if n == nil {
			return
		}
		mutate(&n.Larg, stack, v)
		mutate(&n.Rarg, stack, v)
		mutateList(n.ColTypes, stack, v)
		mutateList(n.ColTypmods, stack, v)
		mutateList(n.ColCollations, stack, v)
		mutateList(n.GroupClauses, stack, v)
	case *GrantStmt:
		if n == nil {
			return
		}
		mutateList(n.Objects, stack, v)
		mutateList(n.Privileges, stack, v)
		mutateList(n.Grantees, stack, v)
	case *GrantRoleStmt:
		if n == nil {
			return
		}
		mutateList(n.GrantedRoles, stack, v)
		mutateList(n.GranteeRoles, stack, v)
		nodeWrapper = n.Grantor
		mutate(&nodeWrapper, stack, v)
	case *AlterDefaultPrivilegesStmt:
		if n == nil {
			return
		}
		mutateList(n.Options, stack, v)
		nodeWrapper = n.Action
		mutate(&nodeWrapper, stack, v)
	case *ClosePortalStmt:
		if n == nil {
			return
		}
	case *ClusterStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Relation
		mutate(&nodeWrapper, stack, v)
	case *CopyStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Relation
		mutate(&nodeWrapper, stack, v)
		mutate(&n.Query, stack, v)
		mutateList(n.Attlist, stack, v)
		mutateList(n.Options, stack, v)
		mutate(&n.WhereClause, stack, v)
	case *CreateStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Relation
		mutate(&nodeWrapper, stack, v)
		mutateList(n.TableElts, stack, v)
		mutateList(n.InhRelations, stack, v)
		nodeWrapper = n.Partbound
		mutate(&nodeWrapper, stack, v)
		nodeWrapper = n.Partspec
		mutate(&nodeWrapper, stack, v)
		nodeWrapper = n.OfTypename
		mutate(&nodeWrapper, stack, v)
		mutateList(n.Constraints, stack, v)
		mutateList(n.Options, stack, v)
	case *DefineStmt:
		if n == nil {
			return
		}
		mutateList(n.Defnames, stack, v)
		mutateList(n.Args, stack, v)
		mutateList(n.Definition, stack, v)
	case *DropStmt:
		if n == nil {
			return
		}
		mutateList(n.Objects, stack, v)
	case *TruncateStmt:
		if n == nil {
			return
		}
		mutateList(n.Relations, stack, v)
	case *CommentStmt:
		if n == nil {
			return
		}
		mutate(&n.Object, stack, v)
	case *FetchStmt:
		if n == nil {
			return
		}
	case *IndexStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Relation
		mutate(&nodeWrapper, stack, v)
		mutateList(n.IndexParams, stack, v)
		mutateList(n.IndexIncludingParams, stack, v)
		mutateList(n.Options, stack, v)
		mutate(&n.WhereClause, stack, v)
		mutateList(n.ExcludeOpNames, stack, v)
	case *CreateFunctionStmt:
		if n == nil {
			return
		}
		mutateList(n.Funcname, stack, v)
		mutateList(n.Parameters, stack, v)
		nodeWrapper = n.ReturnType
		mutate(&nodeWrapper, stack, v)
		mutateList(n.Options, stack, v)
	case *AlterFunctionStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Func
		mutate(&nodeWrapper, stack, v)
		mutateList(n.Actions, stack, v)
	case *DoStmt:
		if n == nil {
			return
		}
		mutateList(n.Args, stack, v)
	case *RenameStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Relation
		mutate(&nodeWrapper, stack, v)
		mutate(&n.Object, stack, v)
	case *RuleStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Relation
		mutate(&nodeWrapper, stack, v)
		mutate(&n.WhereClause, stack, v)
		mutateList(n.Actions, stack, v)
	case *NotifyStmt:
		if n == nil {
			return
		}
	case *ListenStmt:
		if n == nil {
			return
		}
	case *UnlistenStmt:
		if n == nil {
			return
		}
	case *TransactionStmt:
		if n == nil {
			return
		}
		mutateList(n.Options, stack, v)
	case *ViewStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.View
		mutate(&nodeWrapper, stack, v)
		mutateList(n.Aliases, stack, v)
		mutate(&n.Query, stack, v)
		mutateList(n.Options, stack, v)
	case *LoadStmt:
		if n == nil {
			return
		}
	case *CreateDomainStmt:
		if n == nil {
			return
		}
		mutateList(n.Domainname, stack, v)
		nodeWrapper = n.TypeName
		mutate(&nodeWrapper, stack, v)
		nodeWrapper = n.CollClause
		mutate(&nodeWrapper, stack, v)
		mutateList(n.Constraints, stack, v)
	case *CreatedbStmt:
		if n == nil {
			return
		}
		mutateList(n.Options, stack, v)
	case *DropdbStmt:
		if n == nil {
			return
		}
	case *VacuumStmt:
		if n == nil {
			return
		}
		mutateList(n.Options, stack, v)
		mutateList(n.Rels, stack, v)
	case *ExplainStmt:
		if n == nil {
			return
		}
		mutate(&n.Query, stack, v)
		mutateList(n.Options, stack, v)
	case *CreateTableAsStmt:
		if n == nil {
			return
		}
		mutate(&n.Query, stack, v)
		nodeWrapper = n.Into
		mutate(&nodeWrapper, stack, v)
	case *CreateSeqStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Sequence
		mutate(&nodeWrapper, stack, v)
		mutateList(n.Options, stack, v)
	case *AlterSeqStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Sequence
		mutate(&nodeWrapper, stack, v)
		mutateList(n.Options, stack, v)
	case *VariableSetStmt:
		if n == nil {
			return
		}
		mutateList(n.Args, stack, v)
	case *VariableShowStmt:
		if n == nil {
			return
		}
	case *DiscardStmt:
		if n == nil {
			return
		}
	case *CreateTrigStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Relation
		mutate(&nodeWrapper, stack, v)
		mutateList(n.Funcname, stack, v)
		mutateList(n.Args, stack, v)
		mutateList(n.Columns, stack, v)
		mutate(&n.WhenClause, stack, v)
		mutateList(n.TransitionRels, stack, v)
		nodeWrapper = n.Constrrel
		mutate(&nodeWrapper, stack, v)
	case *CreatePlangStmt:
		if n == nil {
			return
		}
		mutateList(n.Plhandler, stack, v)
		mutateList(n.Plinline, stack, v)
		mutateList(n.Plvalidator, stack, v)
	case *CreateRoleStmt:
		if n == nil {
			return
		}
		mutateList(n.Options, stack, v)
	case *AlterRoleStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Role
		mutate(&nodeWrapper, stack, v)
		mutateList(n.Options, stack, v)
	case *DropRoleStmt:
		if n == nil {
			return
		}
		mutateList(n.Roles, stack, v)
	case *LockStmt:
		if n == nil {
			return
		}
		mutateList(n.Relations, stack, v)
	case *ConstraintsSetStmt:
		if n == nil {
			return
		}
		mutateList(n.Constraints, stack, v)
	case *ReindexStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Relation
		mutate(&nodeWrapper, stack, v)
	case *CheckPointStmt:
		if n == nil {
			return
		}
	case *CreateSchemaStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Authrole
		mutate(&nodeWrapper, stack, v)
		mutateList(n.SchemaElts, stack, v)
	case *AlterDatabaseStmt:
		if n == nil {
			return
		}
		mutateList(n.Options, stack, v)
	case *AlterDatabaseSetStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Setstmt
		mutate(&nodeWrapper, stack, v)
	case *AlterRoleSetStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Role
		mutate(&nodeWrapper, stack, v)
		nodeWrapper = n.Setstmt
		mutate(&nodeWrapper, stack, v)
	case *CreateConversionStmt:
		if n == nil {
			return
		}
		mutateList(n.ConversionName, stack, v)
		mutateList(n.FuncName, stack, v)
	case *CreateCastStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Sourcetype
		mutate(&nodeWrapper, stack, v)
		nodeWrapper = n.Targettype
		mutate(&nodeWrapper, stack, v)
		nodeWrapper = n.Func
		mutate(&nodeWrapper, stack, v)
	case *CreateOpClassStmt:
		if n == nil {
			return
		}
		mutateList(n.Opclassname, stack, v)
		mutateList(n.Opfamilyname, stack, v)
		nodeWrapper = n.Datatype
		mutate(&nodeWrapper, stack, v)
		mutateList(n.Items, stack, v)
	case *CreateOpFamilyStmt:
		if n == nil {
			return
		}
		mutateList(n.Opfamilyname, stack, v)
	case *AlterOpFamilyStmt:
		if n == nil {
			return
		}
		mutateList(n.Opfamilyname, stack, v)
		mutateList(n.Items, stack, v)
	case *PrepareStmt:
		if n == nil {
			return
		}
		mutateList(n.Argtypes, stack, v)
		mutate(&n.Query, stack, v)
	case *ExecuteStmt:
		if n == nil {
			return
		}
		mutateList(n.Params, stack, v)
	case *DeallocateStmt:
		if n == nil {
			return
		}
	case *DeclareCursorStmt:
		if n == nil {
			return
		}
		mutate(&n.Query, stack, v)
	case *CreateTableSpaceStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Owner
		mutate(&nodeWrapper, stack, v)
		mutateList(n.Options, stack, v)
	case *DropTableSpaceStmt:
		if n == nil {
			return
		}
	case *AlterObjectDependsStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Relation
		mutate(&nodeWrapper, stack, v)
		mutate(&n.Object, stack, v)
		mutate(&n.Extname, stack, v)
	case *AlterObjectSchemaStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Relation
		mutate(&nodeWrapper, stack, v)
		mutate(&n.Object, stack, v)
	case *AlterOwnerStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Relation
		mutate(&nodeWrapper, stack, v)
		mutate(&n.Object, stack, v)
		nodeWrapper = n.Newowner
		mutate(&nodeWrapper, stack, v)
	case *AlterOperatorStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Opername
		mutate(&nodeWrapper, stack, v)
		mutateList(n.Options, stack, v)
	case *DropOwnedStmt:
		if n == nil {
			return
		}
		mutateList(n.Roles, stack, v)
	case *ReassignOwnedStmt:
		if n == nil {
			return
		}
		mutateList(n.Roles, stack, v)
		nodeWrapper = n.Newrole
		mutate(&nodeWrapper, stack, v)
	case *CompositeTypeStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Typevar
		mutate(&nodeWrapper, stack, v)
		mutateList(n.Coldeflist, stack, v)
	case *CreateEnumStmt:
		if n == nil {
			return
		}
		mutateList(n.TypeName, stack, v)
		mutateList(n.Vals, stack, v)
	case *CreateRangeStmt:
		if n == nil {
			return
		}
		mutateList(n.TypeName, stack, v)
		mutateList(n.Params, stack, v)
	case *AlterEnumStmt:
		if n == nil {
			return
		}
		mutateList(n.TypeName, stack, v)
	case *AlterTsdictionaryStmt:
		if n == nil {
			return
		}
		mutateList(n.Dictname, stack, v)
		mutateList(n.Options, stack, v)
	case *AlterTsconfigurationStmt:
		if n == nil {
			return
		}
		mutateList(n.Cfgname, stack, v)
		mutateList(n.Tokentype, stack, v)
		mutateList(n.Dicts, stack, v)
	case *CreateFdwStmt:
		if n == nil {
			return
		}
		mutateList(n.FuncOptions, stack, v)
		mutateList(n.Options, stack, v)
	case *AlterFdwStmt:
		if n == nil {
			return
		}
		mutateList(n.FuncOptions, stack, v)
		mutateList(n.Options, stack, v)
	case *CreateForeignServerStmt:
		if n == nil {
			return
		}
		mutateList(n.Options, stack, v)
	case *AlterForeignServerStmt:
		if n == nil {
			return
		}
		mutateList(n.Options, stack, v)
	case *CreateUserMappingStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.User
		mutate(&nodeWrapper, stack, v)
		mutateList(n.Options, stack, v)
	case *AlterUserMappingStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.User
		mutate(&nodeWrapper, stack, v)
		mutateList(n.Options, stack, v)
	case *DropUserMappingStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.User
		mutate(&nodeWrapper, stack, v)
	case *AlterTableSpaceOptionsStmt:
		if n == nil {
			return
		}
		mutateList(n.Options, stack, v)
	case *AlterTableMoveAllStmt:
		if n == nil {
			return
		}
		mutateList(n.Roles, stack, v)
	case *SecLabelStmt:
		if n == nil {
			return
		}
		mutate(&n.Object, stack, v)
	case *CreateForeignTableStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Base
		mutate(&nodeWrapper, stack, v)
		mutateList(n.Options, stack, v)
	case *ImportForeignSchemaStmt:
		if n == nil {
			return
		}
		mutateList(n.TableList, stack, v)
		mutateList(n.Options, stack, v)
	case *CreateExtensionStmt:
		if n == nil {
			return
		}
		mutateList(n.Options, stack, v)
	case *AlterExtensionStmt:
		if n == nil {
			return
		}
		mutateList(n.Options, stack, v)
	case *AlterExtensionContentsStmt:
		if n == nil {
			return
		}
		mutate(&n.Object, stack, v)
	case *CreateEventTrigStmt:
		if n == nil {
			return
		}
		mutateList(n.Whenclause, stack, v)
		mutateList(n.Funcname, stack, v)
	case *AlterEventTrigStmt:
		if n == nil {
			return
		}
	case *RefreshMatViewStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Relation
		mutate(&nodeWrapper, stack, v)
	case *ReplicaIdentityStmt:
		if n == nil {
			return
		}
	case *AlterSystemStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Setstmt
		mutate(&nodeWrapper, stack, v)
	case *CreatePolicyStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Table
		mutate(&nodeWrapper, stack, v)
		mutateList(n.Roles, stack, v)
		mutate(&n.Qual, stack, v)
		mutate(&n.WithCheck, stack, v)
	case *AlterPolicyStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Table
		mutate(&nodeWrapper, stack, v)
		mutateList(n.Roles, stack, v)
		mutate(&n.Qual, stack, v)
		mutate(&n.WithCheck, stack, v)
	case *CreateTransformStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.TypeName
		mutate(&nodeWrapper, stack, v)
		nodeWrapper = n.Fromsql
		mutate(&nodeWrapper, stack, v)
		nodeWrapper = n.Tosql
		mutate(&nodeWrapper, stack, v)
	case *CreateAmStmt:
		if n == nil {
			return
		}
		mutateList(n.HandlerName, stack, v)
	case *CreatePublicationStmt:
		if n == nil {
			return
		}
		mutateList(n.Options, stack, v)
		mutateList(n.Tables, stack, v)
	case *AlterPublicationStmt:
		if n == nil {
			return
		}
		mutateList(n.Options, stack, v)
		mutateList(n.Tables, stack, v)
	case *CreateSubscriptionStmt:
		if n == nil {
			return
		}
		mutateList(n.Publication, stack, v)
		mutateList(n.Options, stack, v)
	case *AlterSubscriptionStmt:
		if n == nil {
			return
		}
		mutateList(n.Publication, stack, v)
		mutateList(n.Options, stack, v)
	case *DropSubscriptionStmt:
		if n == nil {
			return
		}
	case *CreateStatsStmt:
		if n == nil {
			return
		}
		mutateList(n.Defnames, stack, v)
		mutateList(n.StatTypes, stack, v)
		mutateList(n.Exprs, stack, v)
		mutateList(n.Relations, stack, v)
	case *AlterCollationStmt:
		if n == nil {
			return
		}
		mutateList(n.Collname, stack, v)
	case *CallStmt:
		if n == nil {
			return
		}
		nodeWrapper = n.Funccall
		mutate(&nodeWrapper, stack, v)
		nodeWrapper = n.Funcexpr
		mutate(&nodeWrapper, stack, v)
	case *AExpr:
		if n == nil {
			return
		}
		mutateList(n.Name, stack, v)
		mutate(&n.Lexpr, stack, v)
		mutate(&n.Rexpr, stack, v)
	case *ColumnRef:
		if n == nil {
			return
		}
		mutateList(n.Fields, stack, v)
	case *ParamRef:
		if n == nil {
			return
		}
	case *AConst:
		if n == nil {
			return
		}
		mutate(&n.Val, stack, v)
	case *FuncCall:
		if n == nil {
			return
		}
		mutateList(n.Funcname, stack, v)
		mutateList(n.Args, stack, v)
		mutateList(n.AggOrder, stack, v)
		mutate(&n.AggFilter, stack, v)
		nodeWrapper = n.Over
		mutate(&nodeWrapper, stack, v)
	case *AStar:
		if n == nil {
			return
		}
	case *AIndices:
		if n == nil {
			return
		}
		mutate(&n.Lidx, stack, v)
		mutate(&n.Uidx, stack, v)
	case *AIndirection:
		if n == nil {
			return
		}
		mutate(&n.Arg, stack, v)
		mutateList(n.Indirection, stack, v)
	case *AArrayExpr:
		if n == nil {
			return
		}
		mutateList(n.Elements, stack, v)
	case *ResTarget:
		if n == nil {
			return
		}
		mutateList(n.Indirection, stack, v)
		mutate(&n.Val, stack, v)
	case *MultiAssignRef:
		if n == nil {
			return
		}
		mutate(&n.Source, stack, v)
	case *TypeCast:
		if n == nil {
			return
		}
		mutate(&n.Arg, stack, v)
		nodeWrapper = n.TypeName
		mutate(&nodeWrapper, stack, v)
	case *CollateClause:
		if n == nil {
			return
		}
		mutate(&n.Arg, stack, v)
		mutateList(n.Collname, stack, v)
	case *SortBy:
		if n == nil {
			return
		}
		mutate(&n.Node, stack, v)
		mutateList(n.UseOp, stack, v)
	case *WindowDef:
		if n == nil {
			return
		}
		mutateList(n.PartitionClause, stack, v)
		mutateList(n.OrderClause, stack, v)
		mutate(&n.StartOffset, stack, v)
		mutate(&n.EndOffset, stack, v)
	case *RangeSubselect:
		if n == nil {
			return
		}
		mutate(&n.Subquery, stack, v)
		nodeWrapper = n.Alias
		mutate(&nodeWrapper, stack, v)
	case *RangeFunction:
		if n == nil {
			return
		}
		mutateList(n.Functions, stack, v)
		nodeWrapper = n.Alias
		mutate(&nodeWrapper, stack, v)
		mutateList(n.Coldeflist, stack, v)
	case *RangeTableSample:
		if n == nil {
			return
		}
		mutate(&n.Relation, stack, v)
		mutateList(n.Method, stack, v)
		mutateList(n.Args, stack, v)
		mutate(&n.Repeatable, stack, v)
	case *RangeTableFunc:
		if n == nil {
			return
		}
		mutate(&n.Docexpr, stack, v)
		mutate(&n.Rowexpr, stack, v)
		mutateList(n.Namespaces, stack, v)
		mutateList(n.Columns, stack, v)
		nodeWrapper = n.Alias
		mutate(&nodeWrapper, stack, v)
	case *RangeTableFuncCol:
		if n == nil {
			return
		}
		nodeWrapper = n.TypeName
		mutate(&nodeWrapper, stack, v)
		mutate(&n.Colexpr, stack, v)
		mutate(&n.Coldefexpr, stack, v)
	case *TypeName:
		if n == nil {
			return
		}
		mutateList(n.Names, stack, v)
		mutateList(n.Typmods, stack, v)
		mutateList(n.ArrayBounds, stack, v)
	case *ColumnDef:
		if n == nil {
			return
		}
		nodeWrapper = n.TypeName
		mutate(&nodeWrapper, stack, v)
		mutate(&n.RawDefault, stack, v)
		mutate(&n.CookedDefault, stack, v)
		nodeWrapper = n.IdentitySequence
		mutate(&nodeWrapper, stack, v)
		nodeWrapper = n.CollClause
		mutate(&nodeWrapper, stack, v)
		mutateList(n.Constraints, stack, v)
		mutateList(n.Fdwoptions, stack, v)
	case *IndexElem:
		if n == nil {
			return
		}
		mutate(&n.Expr, stack, v)
		mutateList(n.Collation, stack, v)
		mutateList(n.Opclass, stack, v)
	case *Constraint:
		if n == nil {
			return
		}
		mutate(&n.RawExpr, stack, v)
		mutateList(n.Keys, stack, v)
		mutateList(n.Including, stack, v)
		mutateList(n.Exclusions, stack, v)
		mutateList(n.Options, stack, v)
		mutate(&n.WhereClause, stack, v)
		nodeWrapper = n.Pktable
		mutate(&nodeWrapper, stack, v)
		mutateList(n.FkAttrs, stack, v)
		mutateList(n.PkAttrs, stack, v)
		mutateList(n.OldConpfeqop, stack, v)
	case *DefElem:
		if n == nil {
			return
		}
		mutate(&n.Arg, stack, v)
	case *RangeTblEntry:
		if n == nil {
			return
		}
		nodeWrapper = n.Tablesample
		mutate(&nodeWrapper, stack, v)
		nodeWrapper = n.Subquery
		mutate(&nodeWrapper, stack, v)
		mutateList(n.Joinaliasvars, stack, v)
		mutateList(n.Functions, stack, v)
		nodeWrapper = n.Tablefunc
		mutate(&nodeWrapper, stack, v)
		mutateList(n.ValuesLists, stack, v)
		mutateList(n.Coltypes, stack, v)
		mutateList(n.Coltypmods, stack, v)
		mutateList(n.Colcollations, stack, v)
		nodeWrapper = n.Alias
		mutate(&nodeWrapper, stack, v)
		nodeWrapper = n.Eref
		mutate(&nodeWrapper, stack, v)
		mutateList(n.SecurityQuals, stack, v)
	case *RangeTblFunction:
		if n == nil {
			return
		}
		mutate(&n.Funcexpr, stack, v)
		mutateList(n.Funccolnames, stack, v)
		mutateList(n.Funccoltypes, stack, v)
		mutateList(n.Funccoltypmods, stack, v)
		mutateList(n.Funccolcollations, stack, v)
	case *TableSampleClause:
		if n == nil {
			return
		}
		mutateList(n.Args, stack, v)
		mutate(&n.Repeatable, stack, v)
	case *WithCheckOption:
		if n == nil {
			return
		}
		mutate(&n.Qual, stack, v)
	case *SortGroupClause:
		if n == nil {
			return
		}
	case *GroupingSet:
		if n == nil {
			return
		}
		mutateList(n.Content, stack, v)
	case *WindowClause:
		if n == nil {
			return
		}
		mutateList(n.PartitionClause, stack, v)
		mutateList(n.OrderClause, stack, v)
		mutate(&n.StartOffset, stack, v)
		mutate(&n.EndOffset, stack, v)
	case *ObjectWithArgs:
		if n == nil {
			return
		}
		mutateList(n.Objname, stack, v)
		mutateList(n.Objargs, stack, v)
	case *AccessPriv:
		if n == nil {
			return
		}
		mutateList(n.Cols, stack, v)
	case *CreateOpClassItem:
		if n == nil {
			return
		}
		nodeWrapper = n.Name
		mutate(&nodeWrapper, stack, v)
		mutateList(n.OrderFamily, stack, v)
		mutateList(n.ClassArgs, stack, v)
		nodeWrapper = n.Storedtype
		mutate(&nodeWrapper, stack, v)
	case *TableLikeClause:
		if n == nil {
			return
		}
		nodeWrapper = n.Relation
		mutate(&nodeWrapper, stack, v)
	case *FunctionParameter:
		if n == nil {
			return
		}
		nodeWrapper = n.ArgType
		mutate(&nodeWrapper, stack, v)
		mutate(&n.Defexpr, stack, v)
	case *LockingClause:
		if n == nil {
			return
		}
		mutateList(n.LockedRels, stack, v)
	case *RowMarkClause:
		if n == nil {
			return
		}
	case *XmlSerialize:
		if n == nil {
			return
		}
		mutate(&n.Expr, stack, v)
		nodeWrapper = n.TypeName
		mutate(&nodeWrapper, stack, v)
	case *WithClause:
		if n == nil {
			return
		}
		mutateList(n.Ctes, stack, v)
	case *InferClause:
		if n == nil {
			return
		}
		mutateList(n.IndexElems, stack, v)
		mutate(&n.WhereClause, stack, v)
	case *OnConflictClause:
		if n == nil {
			return
		}
		nodeWrapper = n.Infer
		mutate(&nodeWrapper, stack, v)
		mutateList(n.TargetList, stack, v)
		mutate(&n.WhereClause, stack, v)
	case *CommonTableExpr:
		if n == nil {
			return
		}
		mutateList(n.Aliascolnames, stack, v)
		mutate(&n.Ctequery, stack, v)
		mutateList(n.Ctecolnames, stack, v)
		mutateList(n.Ctecoltypes, stack, v)
		mutateList(n.Ctecoltypmods, stack, v)
		mutateList(n.Ctecolcollations, stack, v)
	case *RoleSpec:
		if n == nil {
			return
		}
	case *TriggerTransition:
		if n == nil {
			return
		}
	case *PartitionElem:
		if n == nil {
			return
		}
		mutate(&n.Expr, stack, v)
		mutateList(n.Collation, stack, v)
		mutateList(n.Opclass, stack, v)
	case *PartitionSpec:
		if n == nil {
			return
		}
		mutateList(n.PartParams, stack, v)
	case *PartitionBoundSpec:
		if n == nil {
			return
		}
		mutateList(n.Listdatums, stack, v)
		mutateList(n.Lowerdatums, stack, v)
		mutateList(n.Upperdatums, stack, v)
	case *PartitionRangeDatum:
		if n == nil {
			return
		}
		mutate(&n.Value, stack, v)
	case *PartitionCmd:
		if n == nil {
			return
		}
		nodeWrapper = n.Name
		mutate(&nodeWrapper, stack, v)
		nodeWrapper = n.Bound
		mutate(&nodeWrapper, stack, v)
	case *VacuumRelation:
		if n == nil {
			return
		}
		nodeWrapper = n.Relation
		mutate(&nodeWrapper, stack, v)
		mutateList(n.VaCols, stack, v)
	case *InlineCodeBlock:
		if n == nil {
			return
		}
	case *CallContext:
		if n == nil {
			return
		}
	case *Root:
		mutate(&n.Node, stack, v)
	case Nodes:
		mutateList(n, stack, v)
	default:
		fmt.Printf("!!mutate missing type:%s\n", reflect.TypeOf(node).Name())
	}
}
